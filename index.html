<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Radio Scheduler</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- html2canvas for screenshots -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <!-- jsPDF for PDF generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* Custom styles for Inter font and general body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to start to allow scrolling if content is long */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        /* Ensure inputs and buttons have consistent styling */
        input[type="text"], input[type="number"], input[type="date"], select, button {
            border-radius: 0.5rem; /* Rounded corners */
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db; /* Light gray border */
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); /* Subtle shadow */
        }
        button {
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }
        button:hover {
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
        }
        /* Table styling for better readability */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            border-radius: 0.5rem;
            overflow: hidden; /* Ensures rounded corners apply to table content */
            table-layout: fixed; /* Ensures columns respect width percentages */
        }
        th, td {
            padding: 1rem;
            text-align: left;
            border-bottom: 1px solid #e5e7eb; /* Lighter gray border for rows */
            word-wrap: break-word; /* Allow long words to break */
            overflow-wrap: break-word; /* Standard property */
            white-space: normal; /* Ensure text wraps naturally */
        }
        th {
            background-color: #1f2937; /* Darker header background */
            color: #ffffff; /* White text for header */
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: #f9fafb; /* Slightly different background for even rows */
        }
        /* Highlight colors based on type */
        .type-song {
            background-color: #dcfce7; /* Light green */
        }
        .type-talk {
            background-color: #e0f2fe; /* Light blue */
        }
        .type-intro {
            background-color: #fef9c3; /* Light yellow */
        }
        tr.total-row {
            background-color: #e0f2fe; /* Light blue for total rows */
            font-weight: bold;
            color: #1e40af; /* Darker blue text */
        }
        tr.total-row td {
            border-top: 2px solid #93c5fd; /* Stronger border above total */
        }
        tr:last-child td {
            border-bottom: none; /* No border for the last row */
        }
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none; /* Hidden by default */
            text-align: center;
        }
        .message-box button {
            margin-top: 15px;
            background-color: #4f46e5;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.5rem;
            z-index: 1001;
            display: none; /* Hidden by default */
        }
        .saved-schedule-item {
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1rem;
            background-color: #ffffff;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        .saved-schedule-item img {
            max-width: 100%;
            height: auto;
            border-radius: 0.25rem;
            margin-top: 0.5rem;
            border: 1px solid #d1d5db;
        }

        /* Specific table column widths for screenshot content */
        #screenshotContent table th:nth-child(1), /* Type */
        #screenshotContent table td:nth-child(1) {
            width: 12%; /* Adjusted */
        }
        #screenshotContent table th:nth-child(2), /* Artist */
        #screenshotContent table td:nth-child(2) {
            width: 28%; /* Adjusted */
        }
        #screenshotContent table th:nth-child(3), /* Song Name */
        #screenshotContent table td:nth-child(3) {
            width: 30%; /* Remains the same */
        }
        #screenshotContent table th:nth-child(4), /* Length */
        #screenshotContent table td:nth-child(4) {
            width: 12%; /* Adjusted */
        }
        #screenshotContent table th:nth-child(5), /* Actions */
        #screenshotContent table td:nth-child(5) {
            width: 18%; /* Adjusted */
        }

        /* New modal for notes */
        .notes-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1002;
            display: none; /* Hidden by default */
        }
        .notes-modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
        }
        .notes-modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #1f2937;
        }
        .notes-modal-content p {
            font-size: 1rem;
            color: #374151;
            margin-bottom: 20px;
            white-space: pre-wrap; /* Preserves whitespace and line breaks */
            text-align: left;
        }
        .notes-modal-content button {
            background-color: #4f46e5;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .notes-modal-content button:hover {
            background-color: #4338ca;
        }

        /* Drag and Drop Styles */
        .draggable-item {
            cursor: grab;
        }

        .draggable-item.dragging {
            opacity: 0.4;
            cursor: grabbing;
        }

        .draggable-item.drag-over-top {
            border-top: 2px solid #4f46e5; /* Indicate drop zone above */
        }

        .draggable-item.drag-over-bottom {
            border-bottom: 2px solid #4f46e5; /* Indicate drop zone below */
        }

        /* Style for dropping into an empty table */
        tbody.drag-over-empty {
            outline: 2px dashed #4f46e5;
            outline-offset: -5px;
        }

        /* Hide the "No entries yet" message during drag-over an empty table */
        tbody.drag-over-empty td[colspan="5"] {
            display: none;
        }
    </style>
</head>
<body class="antialiased">
    <div class="container mx-auto p-6 bg-white shadow-xl rounded-lg max-w-4xl w-full" id="schedulerContainer">
        <h1 class="text-4xl font-extrabold text-gray-900 mb-4 text-center">Radio Scheduler</h1>

        <div class="mb-6 flex justify-center items-center gap-2">
            <label for="scheduleDate" class="text-lg font-medium text-gray-700">Schedule Date:</label>
            <input type="date" id="scheduleDate" class="p-2 rounded-md border-gray-300 shadow-sm focus:ring-indigo-500 focus:border-indigo-500">
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
            <input type="text" id="artistNameInput" placeholder="Artist" class="col-span-1 focus:ring-indigo-500 focus:border-indigo-500 block w-full rounded-md sm:text-sm border-gray-300">
            <input type="text" id="songNameInput" placeholder="Song Name" class="col-span-1 focus:ring-indigo-500 focus:border-indigo-500 block w-full rounded-md sm:text-sm border-gray-300">
            <input type="text" id="notesInput" placeholder="Notes" class="col-span-1 focus:ring-indigo-500 focus:border-indigo-500 block w-full rounded-md sm:text-sm border-gray-300">
            <input type="number" id="minutes" placeholder="Min" class="col-span-1 focus:ring-indigo-500 focus:border-indigo-500 block w-full rounded-md sm:text-sm border-gray-300">
            <input type="number" id="seconds" placeholder="Sec" class="col-span-1 focus:ring-indigo-500 focus:border-indigo-500 block w-full rounded-md sm:text-sm border-gray-300">
            <select id="targetHour" class="col-span-1 focus:ring-indigo-500 focus:border-indigo-500 block w-full rounded-md sm:text-sm border-gray-300">
                <option value="1">Hour 1</option>
                <option value="2">Hour 2</option>
            </select>
            <button id="addEntryBtn" class="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 col-span-full md:col-span-1">Update Entry</button>
            <button id="cancelEditBtn" class="bg-gray-400 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105 col-span-full md:col-span-1 hidden">Cancel Edit</button>
        </div>

        <div class="flex flex-wrap justify-center gap-4 mb-8">
            <button id="addTalkTypeBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Add Talk</button>
            <button id="addIntroTypeBtn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Add Intro</button>
        </div>

        <div class="flex flex-wrap justify-center gap-4 mb-8">
            <button id="downloadScreenshotBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Download Schedule (PDF)</button>
            <button id="downloadNotesBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">Download Notes (PDF)</button>
        </div>

        <div id="screenshotContent">
            <h2 id="screenshotDateDisplay" class="text-2xl font-bold text-gray-800 mb-4 text-center"></h2>
            <div class="mb-8 p-4 bg-gray-50 rounded-lg shadow-sm">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Hour 1 Schedule</h2>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Type</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Artist</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Song Name</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Length</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="hour1SongList" class="bg-white divide-y divide-gray-200">
                            </tbody>
                    </table>
                </div>
                <div class="text-right text-xl font-semibold text-gray-700 mt-4">
                    Total for Hour 1: <span id="totalDurationHour1">00h 00m 00s</span>
                </div>
            </div>

            <div class="mb-8 p-4 bg-gray-50 rounded-lg shadow-sm">
                <h2 class="text-2xl font-bold text-gray-800 mb-4 text-center">Hour 2 Schedule</h2>
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Type</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Artist</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Song Name</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Length</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-200 uppercase tracking-wider">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="hour2SongList" class="bg-white divide-y divide-gray-200">
                            </tbody>
                    </table>
                </div>
                <div class="text-right text-xl font-semibold text-gray-700 mt-4">
                    Total for Hour 2: <span id="totalDurationHour2">00h 00m 00s</span>
                </div>
            </div>

            <!-- Overall Total Duration Display -->
            <div class="text-right text-2xl font-bold text-gray-800 mt-8 p-4 bg-gray-100 rounded-lg shadow-inner">
                Overall Total Duration: <span id="overallTotalDuration">00h 00m 00s</span>
            </div>
        </div>
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="document.getElementById('messageBox').style.display='none'">OK</button>
    </div>

    <div id="notesModal" class="notes-modal">
        <div class="notes-modal-content">
            <h3 id="notesModalTitle">Notes</h3>
            <p id="notesModalContent"></p>
            <button onclick="document.getElementById('notesModal').style.display='none'">OK</button>
        </div>
    </div>

    <div id="loadingOverlay" class="loading-overlay">
        <p>Processing...</p>
    </div>

    <script type="module">
        // Firebase imports (still included for potential future use, but not actively used for save/load)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, deleteDoc, doc, query, orderBy, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Global Firebase variables
        let firebaseApp = null;
        let db = null;
        let auth = null;
        let userId = null;
        let firebaseInitialized = false;

        // Array to store song objects
        let songs = [];
        let editingIndex = null; // To keep track of the song being edited
        let currentEntryType = 'song'; // Default entry type

        // Get references to DOM elements
        const schedulerContainer = document.getElementById('schedulerContainer');
        const scheduleDateInput = document.getElementById('scheduleDate');
        const artistNameInput = document.getElementById('artistNameInput');
        const songNameInput = document.getElementById('songNameInput');
        const notesInput = document.getElementById('notesInput'); // Notes input remains for adding/editing
        const minutesInput = document.getElementById('minutes');
        const secondsInput = document.getElementById('seconds');
        const targetHourSelect = document.getElementById('targetHour');
        const addEntryBtn = document.getElementById('addEntryBtn');
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const hour1SongListBody = document.getElementById('hour1SongList');
        const hour2SongListBody = document.getElementById('hour2SongList');
        const totalDurationHour1Span = document.getElementById('totalDurationHour1');
        const totalDurationHour2Span = document.getElementById('totalDurationHour2'); // Fixed this line
        const overallTotalDurationSpan = document.getElementById('overallTotalDuration');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const loadingOverlay = document.getElementById('loadingOverlay');

        const downloadScreenshotBtn = document.getElementById('downloadScreenshotBtn');
        const downloadNotesBtn = document.getElementById('downloadNotesBtn'); // New button for downloading notes
        const screenshotContent = document.getElementById('screenshotContent'); // Screenshot target
        const screenshotDateDisplay = document.getElementById('screenshotDateDisplay'); // Element to display date in screenshot

        // New type buttons
        const addTalkTypeBtn = document.getElementById('addTalkTypeBtn');
        const addIntroTypeBtn = document.getElementById('addIntroTypeBtn');

        // Notes Modal elements
        const notesModal = document.getElementById('notesModal');
        const notesModalTitle = document.getElementById('notesModalTitle');
        const notesModalContent = document.getElementById('notesModalContent');

        // Initialize jsPDF
        const { jsPDF } = window.jspdf;

        // Drag and Drop state variables
        let draggedItem = null; // Stores the DOM element being dragged

        /**
         * Generates a unique ID (UUID v4).
         * @returns {string} A unique ID.
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Displays a custom message box instead of alert().
         * @param {string} message - The message to display.
         */
        window.showMessageBox = function(message) {
            messageText.textContent = message;
            messageBox.style.display = 'block';
        }

        /**
         * Shows or hides the loading overlay.
         * @param {boolean} show - True to show, false to hide.
         */
        function showLoading(show) {
            loadingOverlay.style.display = show ? 'flex' : 'none';
        }

        /**
         * Converts total seconds into a human-readable H:M:S format.
         * @param {number} totalSeconds - The total duration in seconds.
         * @returns {string} Formatted string (e.g., "01h 05m 30s").
         */
        function formatDuration(totalSeconds) {
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;

            const pad = (num) => num.toString().padStart(2, '0');

            return `${pad(hours)}h ${pad(minutes)}m ${pad(seconds)}s`;
        }

        /**
         * Calculates the total duration of all songs in the `songs` array
         * and updates the overall display, as well as individual hour totals.
         */
        function updateAllDurations() {
            let totalSecondsOverall = 0;
            let totalSecondsHour1 = 0;
            let totalSecondsHour2 = 0;

            songs.forEach(song => {
                totalSecondsOverall += song.lengthInSeconds;
                if (song.targetHour == 1) {
                    totalSecondsHour1 += song.lengthInSeconds;
                } else if (song.targetHour == 2) {
                    totalSecondsHour2 += song.lengthInSeconds;
                }
            });

            overallTotalDurationSpan.textContent = formatDuration(totalSecondsOverall);
            totalDurationHour1Span.textContent = formatDuration(totalSecondsHour1);
            totalDurationHour2Span.textContent = formatDuration(totalSecondsHour2);
        }

        /**
         * Renders the songs into two separate hourly tables based on their targetHour.
         */
        function renderSchedules() {
            hour1SongListBody.innerHTML = ''; // Clear existing list for Hour 1
            hour2SongListBody.innerHTML = ''; // Clear existing list for Hour 2

            const hour1Songs = songs.filter(song => song.targetHour == 1);
            const hour2Songs = songs.filter(song => song.targetHour == 2);

            // Helper to render a list of songs into a tbody
            const renderSongsIntoTable = (songArray, tbodyElement) => {
                if (songArray.length === 0) {
                    const noSongsRow = document.createElement('tr');
                    // Adjusted colspan to 5 as Notes column is not visible in live view
                    noSongsRow.innerHTML = `<td colspan="5" class="text-center py-4 text-gray-500 italic">No entries added yet.</td>`;
                    tbodyElement.appendChild(noSongsRow);
                } else {
                    songArray.forEach(song => { // No need for index here as we use song.id for editing/removing directly
                        const row = document.createElement('tr');
                        // Add class based on entry type for styling
                        row.className = `hover:bg-gray-50 type-${song.type} draggable-item`;
                        row.setAttribute('draggable', 'true'); // Make row draggable
                        row.setAttribute('data-id', song.id); // Store unique ID on the DOM element

                        row.innerHTML = `
                            <td class="px-6 py-4 text-sm font-medium text-gray-900 capitalize">${song.type}</td>
                            <td class="px-6 py-4 text-sm font-medium text-gray-900">${song.artistName}</td>
                            <td class="px-6 py-4 text-sm text-gray-700">${song.songName}</td>
                            <td class="px-6 py-4 text-sm text-gray-700">${formatDuration(song.lengthInSeconds)}</td>
                            <td class="px-6 py-4 text-right text-sm font-medium">
                                <button onclick="editSong('${song.id}')" class="text-blue-600 hover:text-blue-900 bg-blue-100 hover:bg-blue-200 px-3 py-1 rounded-full transition duration-150 ease-in-out mr-2">Edit</button>
                                ${song.notes ? `<button onclick="showNotesPopup('${song.id}')" class="text-purple-600 hover:text-purple-900 bg-purple-100 hover:bg-purple-200 px-3 py-1 rounded-full transition duration-150 ease-in-out mr-2">Info</button>` : ''}
                                <button onclick="removeSong('${song.id}')" class="text-red-600 hover:text-red-900 bg-red-100 hover:bg-red-200 px-3 py-1 rounded-full transition duration-150 ease-in-out">Remove</button>
                            </td>
                        `;
                        tbodyElement.appendChild(row);
                    });
                }
            };

            renderSongsIntoTable(hour1Songs, hour1SongListBody);
            renderSongsIntoTable(hour2Songs, hour2SongListBody);

            updateAllDurations(); // Update all duration displays
        }

        /**
         * Displays the notes for a specific song in a pop-up modal.
         * @param {string} id - The ID of the song whose notes to display.
         */
        window.showNotesPopup = function(id) {
            const song = songs.find(s => s.id === id);
            if (song && song.notes) {
                notesModalTitle.textContent = `Notes for: ${song.artistName} - ${song.songName}`;
                notesModalContent.textContent = song.notes;
                notesModal.style.display = 'flex'; // Show the modal
            } else {
                showMessageBox('No notes available for this entry.');
            }
        }

        /**
         * Sets up the form for editing a song.
         * @param {string} id - The ID of the song to edit.
         */
        window.editSong = function(id) {
            const songToEdit = songs.find(s => s.id === id);
            if (!songToEdit) return;

            artistNameInput.value = songToEdit.artistName;
            songNameInput.value = songToEdit.songName;
            notesInput.value = songToEdit.notes || ''; // Populate notes field
            minutesInput.value = Math.floor(songToEdit.lengthInSeconds / 60);
            secondsInput.value = songToEdit.lengthInSeconds % 60;
            currentEntryType = songToEdit.type; // Set the current entry type for editing
            targetHourSelect.value = songToEdit.targetHour;

            editingIndex = songs.indexOf(songToEdit); // Store the index for array manipulation
            addEntryBtn.textContent = 'Update Entry'; // Change button text
            addEntryBtn.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            addEntryBtn.classList.add('bg-green-600', 'hover:bg-green-700'); // Change button color for update
            cancelEditBtn.classList.remove('hidden'); // Show cancel button
            artistNameInput.focus();
        }

        /**
         * Resets the form to "Add Entry" mode.
         */
        function resetForm() {
            artistNameInput.value = '';
            songNameInput.value = '';
            notesInput.value = ''; // Clear notes field
            minutesInput.value = '';
            secondsInput.value = '';
            currentEntryType = 'song'; // Reset default type to 'song'
            targetHourSelect.value = '1'; // Reset hour selector to Hour 1
            editingIndex = null; // Clear editing index
            addEntryBtn.textContent = 'Add Entry'; // Reset button text
            addEntryBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
            addEntryBtn.classList.add('bg-indigo-600', 'hover:bg-indigo-700'); // Reset button color
            cancelEditBtn.classList.add('hidden'); // Hide cancel button
        }

        /**
         * Handles adding a new entry or updating an existing one.
         * This function is now called by the individual type buttons or the generic "Add Entry" button.
         * @param {string} type - The type of entry (song, talk, intro).
         */
        function handleAddOrUpdateEntry(type) {
            const artistName = artistNameInput.value.trim();
            const songName = songNameInput.value.trim();
            const notes = notesInput.value.trim(); // Get notes value
            const minutes = parseInt(minutesInput.value);
            const seconds = parseInt(secondsInput.value);
            const targetHour = parseInt(targetHourSelect.value);

            // Input validation: Only require duration to be valid
            if (isNaN(minutes) || isNaN(seconds) || minutes < 0 || seconds < 0 || seconds >= 60) {
                showMessageBox('Please enter valid non-negative numbers for minutes and seconds (seconds must be less than 60).');
                return;
            }
            // Allow 0 minutes and 0 seconds for intro type
            if (minutes === 0 && seconds === 0 && type !== 'intro') {
                showMessageBox('Entry length cannot be zero.');
                return;
            }

            const lengthInSeconds = (minutes * 60) + seconds;

            if (editingIndex !== null) {
                // Update existing entry
                songs[editingIndex].artistName = artistName;
                songs[editingIndex].songName = songName;
                songs[editingIndex].notes = notes; // Update notes
                songs[editingIndex].lengthInSeconds = lengthInSeconds;
                songs[editingIndex].type = type;
                songs[editingIndex].targetHour = targetHour;
            } else {
                // Add new entry
                const newEntry = {
                    id: generateUUID(), // Assign a unique ID
                    artistName: artistName,
                    songName: songName,
                    notes: notes, // Add notes to new entry
                    lengthInSeconds: lengthInSeconds,
                    type: type,
                    targetHour: targetHour
                };
                songs.push(newEntry);
            }

            renderSchedules();
            resetForm();
            artistNameInput.focus();
        }

        // Event listener for the main "Update Entry" button (only used for updates now)
        addEntryBtn.addEventListener('click', () => handleAddOrUpdateEntry(currentEntryType));

        // Event listeners for the new type buttons
        addTalkTypeBtn.addEventListener('click', () => {
            // Pre-fill values for "Add Talk"
            artistNameInput.value = 'Talk';
            songNameInput.value = 'Rhian';
            notesInput.value = ''; // Clear notes for prefill
            minutesInput.value = '2';
            secondsInput.value = '0';
            handleAddOrUpdateEntry('talk');
        });
        addIntroTypeBtn.addEventListener('click', () => {
            // Pre-fill values for "Add Intro"
            artistNameInput.value = 'Intro';
            songNameInput.value = 'Rhian';
            notesInput.value = ''; // Clear notes for prefill
            minutesInput.value = '0';
            secondsInput.value = '10';
            handleAddOrUpdateEntry('intro');
        });


        /**
         * Event listener for the Cancel Edit button.
         */
        cancelEditBtn.addEventListener('click', () => {
            resetForm();
            artistNameInput.focus();
        });

        /**
         * Removes a song from the list based on its ID.
         * @param {string} id - The ID of the song to remove.
         */
        window.removeSong = function(id) {
            const indexToRemove = songs.findIndex(song => song.id === id);
            if (indexToRemove > -1) {
                songs.splice(indexToRemove, 1); // Remove 1 element at the given index
                renderSchedules(); // Re-render the schedules
                // If the song being removed was the one being edited, reset the form
                if (editingIndex === indexToRemove) {
                    resetForm();
                } else if (editingIndex > indexToRemove) {
                    // Adjust editingIndex if a song before it was removed
                    editingIndex--;
                }
            }
        }

        /**
         * Generates and downloads the current schedule as a PDF.
         */
        downloadScreenshotBtn.addEventListener('click', async () => {
            showLoading(true);
            try {
                // Update the date display in the screenshot content
                const selectedDate = scheduleDateInput.value;
                if (selectedDate) {
                    const dateObj = new Date(selectedDate);
                    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                    screenshotDateDisplay.textContent = `Schedule for: ${dateObj.toLocaleDateString('en-US', options)}`;
                } else {
                    screenshotDateDisplay.textContent = 'Schedule Date: Not Set';
                }

                await new Promise(resolve => setTimeout(resolve, 100)); // Small delay for rendering

                const canvas = await html2canvas(screenshotContent, {
                    scale: 2, // Increase scale for better quality
                    useCORS: true,
                    logging: false
                });

                const imgData = canvas.toDataURL('image/png');
                const pdf = new jsPDF('p', 'mm', 'a4'); // Portrait, millimeters, A4 size
                const imgWidth = 210; // A4 width in mm
                const pageHeight = 297; // A4 height in mm
                const imgHeight = canvas.height * imgWidth / canvas.width;
                let heightLeft = imgHeight;
                let position = 0;

                pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                heightLeft -= pageHeight;

                while (heightLeft >= 0) {
                    position = heightLeft - imgHeight;
                    pdf.addPage();
                    pdf.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }

                const filename = 'radio_schedule_' + (scheduleDateInput.value || new Date().toISOString().slice(0, 10)) + '.pdf';
                pdf.save(filename);
                showMessageBox("Schedule PDF downloaded successfully!");

            } catch (error) {
                console.error("Error generating schedule PDF:", error);
                showMessageBox("Failed to generate schedule PDF.");
            } finally {
                showLoading(false);
            }
        });

        /**
         * Downloads all notes as a PDF file.
         */
        downloadNotesBtn.addEventListener('click', () => {
            showLoading(true);
            try {
                const pdf = new jsPDF();
                let yPos = 10; // Initial Y position for text

                const selectedDate = scheduleDateInput.value;
                let dateHeader = '';
                if (selectedDate) {
                    const dateObj = new Date(selectedDate);
                    const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
                    dateHeader = `Notes for Radio Schedule on: ${dateObj.toLocaleDateString('en-US', options)}`;
                } else {
                    dateHeader = 'Notes for Radio Schedule (Date Not Set):';
                }

                pdf.setFontSize(16);
                pdf.text(dateHeader, 10, yPos);
                yPos += 15; // Move down for content

                const hasNotes = songs.some(song => song.notes);

                if (!hasNotes) {
                    pdf.setFontSize(12);
                    pdf.text('No notes available for any entries.', 10, yPos);
                } else {
                    pdf.setFontSize(12);
                    songs.forEach((song, index) => {
                        if (song.notes) {
                            const entryHeader = `--- Entry ${index + 1} (${song.type.toUpperCase()}) ---`;
                            const artistLine = `Artist: ${song.artistName || 'N/A'}`;
                            const songLine = `Song/Title: ${song.songName || 'N/A'}`;
                            const notesText = `Notes: ${song.notes}`;

                            // Check if content fits on current page, if not, add new page
                            // Estimate line height for ~12pt font as 7mm
                            const estimatedHeight = 21 + (pdf.splitTextToSize(notesText, pdf.internal.pageSize.width - 20).length * 7); // Header lines + notes lines
                            if (yPos + estimatedHeight + 10 > pdf.internal.pageSize.height - 10) { // 10 for bottom margin
                                pdf.addPage();
                                yPos = 10; // Reset Y position for new page
                            }

                            pdf.text(entryHeader, 10, yPos);
                            yPos += 7;
                            pdf.text(artistLine, 10, yPos);
                            yPos += 7;
                            pdf.text(songLine, 10, yPos);
                            yPos += 7;
                            // Use splitTextToSize for notes to handle wrapping
                            const splitNotes = pdf.splitTextToSize(notesText, pdf.internal.pageSize.width - 20); // 20 for margins
                            pdf.text(splitNotes, 10, yPos);
                            yPos += (splitNotes.length * 7) + 10; // Add height for notes and a gap
                        }
                    });
                }

                const filename = 'radio_schedule_notes_' + (scheduleDateInput.value || new Date().toISOString().slice(0, 10)) + '.pdf';
                pdf.save(filename);
                showMessageBox("Notes PDF downloaded successfully!");
            } catch (error) {
                console.error("Error generating notes PDF:", error);
                showMessageBox("Failed to generate notes PDF.");
            } finally {
                showLoading(false);
            }
        });

        // Drag and Drop Event Handlers
        hour1SongListBody.addEventListener('dragstart', handleDragStart);
        hour1SongListBody.addEventListener('dragover', handleDragOver);
        hour1SongListBody.addEventListener('dragleave', handleDragLeave);
        hour1SongListBody.addEventListener('drop', handleDrop);
        hour1SongListBody.addEventListener('dragend', handleDragEnd);

        hour2SongListBody.addEventListener('dragstart', handleDragStart);
        hour2SongListBody.addEventListener('dragover', handleDragOver);
        hour2SongListBody.addEventListener('dragleave', handleDragLeave);
        hour2SongListBody.addEventListener('drop', handleDrop);
        hour2SongListBody.addEventListener('dragend', handleDragEnd);

        function handleDragStart(e) {
            // Ensure we are dragging a TR element with the draggable-item class
            if (e.target.tagName === 'TR' && e.target.classList.contains('draggable-item')) {
                draggedItem = e.target;
                e.dataTransfer.effectAllowed = 'move';
                // Set the data to be transferred (the unique ID of the song)
                e.dataTransfer.setData('text/plain', draggedItem.dataset.id);
                setTimeout(() => draggedItem.classList.add('dragging'), 0); // Add class after a brief delay
            } else {
                e.preventDefault(); // Don't allow dragging on non-draggable parts
            }
        }

        function handleDragOver(e) {
            e.preventDefault(); // Allow dropping
            e.dataTransfer.dropEffect = 'move'; // Visual feedback for move operation

            // Clear previous drag-over indicators from ALL potential targets
            document.querySelectorAll('.drag-over-top, .drag-over-bottom, .drag-over-empty').forEach(el => {
                el.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over-empty');
            });

            const targetRow = e.target.closest('tr.draggable-item');
            const currentTbody = e.target.closest('tbody');

            // Ensure it's a valid tbody for dropping
            if (currentTbody && (currentTbody.id === 'hour1SongList' || currentTbody.id === 'hour2SongList')) {
                if (targetRow && targetRow !== draggedItem) {
                    // Dropping onto an existing draggable item
                    const rect = targetRow.getBoundingClientRect();
                    const offset = e.clientY - rect.top;

                    if (offset < rect.height / 2) {
                        targetRow.classList.add('drag-over-top');
                    } else {
                        targetRow.classList.add('drag-over-bottom');
                    }
                } else if (!targetRow && currentTbody.childElementCount === 1 && currentTbody.firstElementChild.querySelector('td[colspan="5"]')) {
                    // Dropping into an empty table (which only has the "No entries added yet" placeholder row)
                    currentTbody.classList.add('drag-over-empty');
                } else if (!targetRow && currentTbody.lastElementChild && currentTbody.lastElementChild.classList.contains('draggable-item')) {
                    // Dropping at the very end of a non-empty table (no specific target row below)
                    // Apply 'drag-over-bottom' to the last draggable item
                    currentTbody.lastElementChild.classList.add('drag-over-bottom');
                }
            }
        }

        function handleDragLeave(e) {
            // Check if the relatedTarget (where the mouse is going) is outside the drag-over area
            // This is a common pattern to prevent flickering when moving over child elements
            if (!e.relatedTarget || (!e.relatedTarget.closest('.drag-over-top') && !e.relatedTarget.closest('.drag-over-bottom') && !e.relatedTarget.closest('.drag-over-empty'))) {
                document.querySelectorAll('.drag-over-top, .drag-over-bottom, .drag-over-empty').forEach(el => {
                    el.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over-empty');
                });
            }
        }

        function handleDrop(e) {
            e.preventDefault(); // Prevent default drop behavior (e.g., opening dropped file)

            // Clear all drag-over indicators immediately
            document.querySelectorAll('.drag-over-top, .drag-over-bottom, .drag-over-empty').forEach(el => {
                el.classList.remove('drag-over-top', 'drag-over-bottom', 'drag-over-empty');
            });

            if (!draggedItem) return; // Should not happen if dragstart was correctly handled

            const droppedOnTbody = e.target.closest('tbody');
            if (!droppedOnTbody || (droppedOnTbody.id !== 'hour1SongList' && droppedOnTbody.id !== 'hour2SongList')) {
                // Dropped outside a valid table, or on an invalid part of the table (e.g., thead)
                draggedItem.classList.remove('dragging'); // Remove dragging class if dropped invalidly
                draggedItem = null;
                return;
            }

            const targetRow = e.target.closest('tr.draggable-item');

            // 1. First, visually move the element in the DOM
            if (targetRow && targetRow !== draggedItem) {
                // Dropped on another draggable item
                const rect = targetRow.getBoundingClientRect();
                const offset = e.clientY - rect.top;

                if (offset < rect.height / 2) {
                    // Insert before the target row
                    targetRow.parentNode.insertBefore(draggedItem, targetRow);
                } else {
                    // Insert after the target row
                    targetRow.parentNode.insertBefore(draggedItem, targetRow.nextSibling);
                }
            } else if (droppedOnTbody.childElementCount === 1 && droppedOnTbody.firstElementChild.querySelector('td[colspan="5"]')) {
                // Dropped into an empty table (which has the "no entries" td). Remove the placeholder.
                droppedOnTbody.innerHTML = ''; // Clear the "no entries" row
                droppedOnTbody.appendChild(draggedItem);
            } else {
                // Dropped at the end of a non-empty table (no specific target row identified).
                // Append to the end of the tbody.
                droppedOnTbody.appendChild(draggedItem);
            }

            // 2. Now, reconstruct the 'songs' array based on the new DOM order
            const newSongsArray = [];

            // Helper to process rows in a tbody
            const processTbody = (tbodyElement, targetHourValue) => {
                Array.from(tbodyElement.children).forEach(row => {
                    if (row.classList.contains('draggable-item')) { // Only process draggable items
                        const songId = row.dataset.id;
                        const song = songs.find(s => s.id === songId); // Find the original song object
                        if (song) {
                            song.targetHour = targetHourValue; // Update target hour
                            newSongsArray.push(song);
                        }
                    }
                });
            };

            processTbody(hour1SongListBody, 1);
            processTbody(hour2SongListBody, 2);

            songs = newSongsArray; // Replace the old songs array with the newly ordered one

            // Reset editing state if the edited item was moved
            if (editingIndex !== null) {
                const editedSongId = songs[editingIndex].id; // Get the ID of the song being edited
                editingIndex = songs.findIndex(s => s.id === editedSongId); // Find its new index
                // If the edited song no longer exists (e.g., removed during drag-drop, though not expected here), reset form
                if (editingIndex === -1) {
                    resetForm();
                }
            }

            renderSchedules(); // Re-render to ensure all totals and data are perfectly in sync
        }

        function handleDragEnd(e) {
            // Clean up classes from the dragged item and potential drop targets
            document.querySelectorAll('.dragging, .drag-over-top, .drag-over-bottom, .drag-over-empty').forEach(el => {
                el.classList.remove('dragging', 'drag-over-top', 'drag-over-bottom', 'drag-over-empty');
            });
            draggedItem = null; // Reset the global dragged item reference
        }


        // Firebase initialization is still present for completeness, but save/load schedule functionality is removed.
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
                const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
                const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

                if (Object.keys(firebaseConfig).length === 0) {
                    console.warn("Firebase config not found. Firebase features (if any were enabled) will not work.");
                    return;
                }

                firebaseApp = initializeApp(firebaseConfig);
                db = getFirestore(firebaseApp);
                auth = getAuth(firebaseApp);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase authenticated. User ID:", userId);
                        firebaseInitialized = true;
                    } else {
                        if (initialAuthToken) {
                            try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                console.log("Signed in with custom token.");
                            } catch (error) {
                                console.error("Error authenticating. Some features may not work.");
                                await signInAnonymously(auth);
                                userId = auth.currentUser?.uid || crypto.randomUUID();
                                console.log("Signed in anonymously. User ID:", userId);
                                firebaseInitialized = true;
                            }
                        } else {
                            await signInAnonymously(auth);
                            userId = auth.currentUser?.uid || crypto.randomUUID();
                            console.log("Signed in anonymously. User ID:", userId);
                            firebaseInitialized = true;
                        }
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                showMessageBox("Error initializing Firebase. Please check console for details.");
            }
        });

        // Initial render of the schedule tables
        document.addEventListener('DOMContentLoaded', renderSchedules);
    </script>
</body>
</html>
